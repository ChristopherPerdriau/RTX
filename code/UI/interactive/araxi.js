// WARNING:
// This file was auto-generated by dsl2json.py on: 2020-11-03 03:35:43
//
var araxi_commands = {
  "create_message()": {
    "parameters": {},
    "description": "The `create_message` command creates a basic empty Message object with basic boilerplate metadata\n                such as reasoner_id, schema_version, etc. filled in. This DSL command takes no arguments. This command is not explicitly\n                necessary, as it is called implicitly when needed. e.g. If a DSL program begins with add_qnode(), the\n                create_message() will be executed automatically if there is not yet a Message. If there is already Message in memory,\n                then this command will destroy the previous one (in memory) and begin a new message."
  },
  "add_qnode()": {
    "parameters": {
      "id": {
        "is_required": false,
        "examples": [
          "n00",
          "n01"
        ],
        "default": "",
        "type": "string",
        "description": "Any string that is unique among all QNode id fields, with recommended format n00, n01, n02, etc.\n                        If no value is provided, autoincrementing values beginning for n00 are used."
      },
      "curie": {
        "is_required": false,
        "examples": [
          "DOID:9281",
          "[UniProtKB:P12345,UniProtKB:Q54321]"
        ],
        "type": "string",
        "description": "Any compact URI (CURIE) (e.g. DOID:9281) (May also be a list like [UniProtKB:P12345,UniProtKB:Q54321])"
      },
      "name": {
        "is_required": false,
        "examples": [
          "hypertension",
          "insulin"
        ],
        "type": "string",
        "description": "Any name of a bioentity that will be resolved into a CURIE if possible or result in an error if not (e.g. hypertension, insulin)"
      },
      "type": {
        "is_required": false,
        "examples": [
          "protein",
          "chemical_substance",
          "disease"
        ],
        "type": "ARAXnode",
        "description": "Any valid Translator bioentity type (e.g. protein, chemical_substance, disease)"
      },
      "is_set": {
        "is_required": false,
        "enum": [
          "true",
          "false"
        ],
        "examples": [
          "true",
          "false"
        ],
        "type": "boolean",
        "description": "If set to true, this QNode represents a set of nodes that are all in common between the two other linked QNodes (assumed to be false if not specified)"
      }
    },
    "description": "The `add_qnode` method adds an additional QNode to the QueryGraph in the Message object. Currently\n                when a curie or name is specified, this method will only return success if a matching node is found in the KG1/KG2 KGNodeIndex."
  },
  "add_qedge()": {
    "parameters": {
      "id": {
        "is_required": false,
        "examples": [
          "e00",
          "e01"
        ],
        "default": "",
        "type": "string",
        "description": "Any string that is unique among all QEdge id fields, with recommended format e00, e01, e02, etc.\n                        If no value is provided, autoincrementing values beginning for e00 are used."
      },
      "source_id": {
        "is_required": true,
        "examples": [
          "n00",
          "n01"
        ],
        "type": "string",
        "description": "id of the source QNode already present in the QueryGraph (e.g. n00, n01)"
      },
      "target_id": {
        "is_required": true,
        "examples": [
          "n01",
          "n02"
        ],
        "type": "string",
        "description": "id of the target QNode already present in the QueryGraph (e.g. n01, n02)"
      },
      "type": {
        "is_required": false,
        "examples": [
          "protein",
          "physically_interacts_with",
          "participates_in"
        ],
        "type": "ARAXedge",
        "description": "Any valid Translator/BioLink relationship type (e.g. physically_interacts_with, participates_in)"
      }
    },
    "description": "The `add_qedge` command adds an additional QEdge to the QueryGraph in the Message object. Currently\n                source_id and target_id QNodes must already be present in the QueryGraph. The specified type is not currently checked that it is a\n                valid Translator/BioLink relationship type, but it should be."
  },
  "expand(kp=ARAX/KG1)": {
    "parameters": {
      "edge_id": {
        "is_required": false,
        "examples": [
          "e00",
          "[e00, e01]"
        ],
        "type": "string",
        "description": "A query graph edge ID or list of such IDs to expand (default is to expand entire query graph)."
      },
      "node_id": {
        "is_required": false,
        "examples": [
          "n00",
          "[n00, n01]"
        ],
        "type": "string",
        "description": "A query graph node ID or list of such IDs to expand (default is to expand entire query graph)."
      },
      "continue_if_no_results": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "false",
        "type": "boolean",
        "description": "Whether to continue execution if no paths are found matching the query graph."
      },
      "enforce_directionality": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "false",
        "type": "boolean",
        "description": "Whether to obey (vs. ignore) edge directions in the query graph."
      },
      "use_synonyms": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "true",
        "type": "boolean",
        "description": "Whether to consider curie synonyms and merge synonymous nodes."
      }
    },
    "description": "This command reaches out to the RTX KG1 Neo4j instance to find all bioentity subpaths that satisfy the query graph."
  },
  "expand(kp=ARAX/KG2)": {
    "parameters": {
      "edge_id": {
        "is_required": false,
        "examples": [
          "e00",
          "[e00, e01]"
        ],
        "type": "string",
        "description": "A query graph edge ID or list of such IDs to expand (default is to expand entire query graph)."
      },
      "node_id": {
        "is_required": false,
        "examples": [
          "n00",
          "[n00, n01]"
        ],
        "type": "string",
        "description": "A query graph node ID or list of such IDs to expand (default is to expand entire query graph)."
      },
      "continue_if_no_results": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "false",
        "type": "boolean",
        "description": "Whether to continue execution if no paths are found matching the query graph."
      },
      "enforce_directionality": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "false",
        "type": "boolean",
        "description": "Whether to obey (vs. ignore) edge directions in the query graph."
      },
      "use_synonyms": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "true",
        "type": "boolean",
        "description": "Whether to consider curie synonyms and merge synonymous nodes."
      }
    },
    "description": "This command reaches out to the RTX KG2 knowledge graph to find all bioentity subpaths that satisfy the query graph. If use_synonyms=true, it uses the KG2canonicalized ('KG2c') Neo4j instance; otherwise, the regular KG2 Neo4j instance is used."
  },
  "expand(kp=BTE)": {
    "parameters": {
      "edge_id": {
        "is_required": false,
        "examples": [
          "e00",
          "[e00, e01]"
        ],
        "type": "string",
        "description": "A query graph edge ID or list of such IDs to expand (default is to expand entire query graph)."
      },
      "node_id": {
        "is_required": false,
        "examples": [
          "n00",
          "[n00, n01]"
        ],
        "type": "string",
        "description": "A query graph node ID or list of such IDs to expand (default is to expand entire query graph)."
      },
      "continue_if_no_results": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "false",
        "type": "boolean",
        "description": "Whether to continue execution if no paths are found matching the query graph."
      },
      "enforce_directionality": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "false",
        "type": "boolean",
        "description": "Whether to obey (vs. ignore) edge directions in the query graph."
      },
      "use_synonyms": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "true",
        "type": "boolean",
        "description": "Whether to consider curie synonyms and merge synonymous nodes."
      }
    },
    "description": "This command uses BioThings Explorer (from the Service Provider) to find all bioentity subpaths that satisfy the query graph. Of note, all query nodes must have a type specified for BTE queries. In addition, bi-directional queries are only partially supported (the ARAX system knows how to ignore edge direction when deciding which query node for a query edge will be the 'input' qnode, but BTE itself returns only answers matching the input edge direction)."
  },
  "expand(kp=COHD)": {
    "parameters": {
      "edge_id": {
        "is_required": false,
        "examples": [
          "e00",
          "[e00, e01]"
        ],
        "type": "string",
        "description": "A query graph edge ID or list of such IDs to expand (default is to expand entire query graph)."
      },
      "node_id": {
        "is_required": false,
        "examples": [
          "n00",
          "[n00, n01]"
        ],
        "type": "string",
        "description": "A query graph node ID or list of such IDs to expand (default is to expand entire query graph)."
      },
      "continue_if_no_results": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "false",
        "type": "boolean",
        "description": "Whether to continue execution if no paths are found matching the query graph."
      },
      "use_synonyms": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "true",
        "type": "boolean",
        "description": "Whether to consider curie synonyms and merge synonymous nodes."
      },
      "COHD_method": {
        "is_required": false,
        "examples": [
          "paired_concept_freq",
          "chi_square"
        ],
        "enum": [
          "paired_concept_freq",
          "observed_expected_ratio",
          "chi_square"
        ],
        "default": "paired_concept_freq",
        "type": "string",
        "description": "Which measure from COHD should be considered."
      },
      "COHD_method_percentile": {
        "is_required": false,
        "examples": [
          95,
          80
        ],
        "min": 0,
        "max": 100,
        "default": 99,
        "type": "integer",
        "description": "What percentile to use as a cut-off/threshold for the specified COHD method."
      }
    },
    "description": "This command uses the Clinical Data Provider (COHD) to find all bioentity subpaths that satisfy the query graph."
  },
  "expand(kp=GeneticsKP)": {
    "parameters": {
      "edge_id": {
        "is_required": false,
        "examples": [
          "e00",
          "[e00, e01]"
        ],
        "type": "string",
        "description": "A query graph edge ID or list of such IDs to expand (default is to expand entire query graph)."
      },
      "node_id": {
        "is_required": false,
        "examples": [
          "n00",
          "[n00, n01]"
        ],
        "type": "string",
        "description": "A query graph node ID or list of such IDs to expand (default is to expand entire query graph)."
      },
      "continue_if_no_results": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "false",
        "type": "boolean",
        "description": "Whether to continue execution if no paths are found matching the query graph."
      },
      "use_synonyms": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "true",
        "type": "boolean",
        "description": "Whether to consider curie synonyms and merge synonymous nodes."
      },
      "include_integrated_score": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "false",
        "type": "boolean",
        "description": "Whether to add genetics-quantile edges (in addition to MAGMA edges) from the Genetics KP."
      }
    },
    "description": "This command reaches out to the Genetics Provider to find all bioentity subpaths that satisfy the query graph. It currently can answer questions involving the following node types: gene, protein, disease, phenotypic_feature, pathway. QNode types are required for GeneticsKP queries. Temporarily (while the integration is under development), it can only be used as the first hop in a query. Note that QEdge types are irrelevant for GeneticsKP queries, since GeneticsKP only outputs edges with a type of 'associated' (so Expand always uses that as the QEdge type behind the scenes)."
  },
  "expand(kp=MolePro)": {
    "parameters": {
      "edge_id": {
        "is_required": false,
        "examples": [
          "e00",
          "[e00, e01]"
        ],
        "type": "string",
        "description": "A query graph edge ID or list of such IDs to expand (default is to expand entire query graph)."
      },
      "node_id": {
        "is_required": false,
        "examples": [
          "n00",
          "[n00, n01]"
        ],
        "type": "string",
        "description": "A query graph node ID or list of such IDs to expand (default is to expand entire query graph)."
      },
      "continue_if_no_results": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "false",
        "type": "boolean",
        "description": "Whether to continue execution if no paths are found matching the query graph."
      },
      "use_synonyms": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "true",
        "type": "boolean",
        "description": "Whether to consider curie synonyms and merge synonymous nodes."
      }
    },
    "description": "This command reaches out to MolePro (the Molecular Provider) to find all bioentity subpaths that satisfy the query graph. It currently can answer questions involving the following node types: gene, protein, disease, chemical_substance. QNode types are required for MolePro queries. Generally you should not specify a QEdge type for MolePro queries (Expand uses 'correlated_with' by default behind the scenes, which is the primary edge type of interest for ARAX in MolePro)."
  },
  "expand(kp=NGD)": {
    "parameters": {
      "edge_id": {
        "is_required": false,
        "examples": [
          "e00",
          "[e00, e01]"
        ],
        "type": "string",
        "description": "A query graph edge ID or list of such IDs to expand (default is to expand entire query graph)."
      },
      "node_id": {
        "is_required": false,
        "examples": [
          "n00",
          "[n00, n01]"
        ],
        "type": "string",
        "description": "A query graph node ID or list of such IDs to expand (default is to expand entire query graph)."
      },
      "continue_if_no_results": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "false",
        "type": "boolean",
        "description": "Whether to continue execution if no paths are found matching the query graph."
      },
      "use_synonyms": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "true",
        "type": "boolean",
        "description": "Whether to consider curie synonyms and merge synonymous nodes."
      }
    },
    "description": "This command uses ARAX's in-house normalized google distance (NGD) database to expand a query graph; it returns edges between nodes with an NGD value below a certain threshold. This threshold is currently hardcoded as 0.5, though this will be made configurable/smarter in the future."
  },
  "overlay(action=overlay_exposures_data)": {
    "parameters": {
      "virtual_relation_label": {
        "is_required": false,
        "examples": [
          "N1",
          "J2"
        ],
        "type": "string",
        "description": "An optional label to help identify the virtual edge in the relation field."
      },
      "source_qnode_id": {
        "is_required": false,
        "examples": [
          "n00",
          "n01"
        ],
        "type": "string",
        "description": "A specific source query node id (optional, otherwise applied to all edges, must have a virtual_relation_label to use this parameter)"
      },
      "target_qnode_id": {
        "is_required": false,
        "examples": [
          "n00",
          "n01"
        ],
        "type": "string",
        "description": "A specific target query node id (optional, otherwise applied to all edges, must have a virtual_relation_label to use this parameter)"
      }
    },
    "description": "\noverlay_exposures_data overlays edges with p-values obtained from the ICEES+ (Integrated Clinical and Environmental Exposures Service) knowledge provider.\nThis information is included in edge attributes with the name 'icees_p-value'.\n                    "
  },
  "overlay(action=compute_ngd)": {
    "parameters": {
      "default_value": {
        "is_required": false,
        "examples": [
          "0",
          "inf"
        ],
        "default": "inf",
        "type": "string",
        "description": "The default value of the normalized Google distance (if its value cannot be determined)"
      },
      "virtual_relation_label": {
        "is_required": false,
        "examples": [
          "N1",
          "J2"
        ],
        "type": "string",
        "description": "An optional label to help identify the virtual edge in the relation field."
      },
      "source_qnode_id": {
        "is_required": false,
        "examples": [
          "n00",
          "n01"
        ],
        "type": "string",
        "description": "A specific source query node id (optional, otherwise applied to all edges, must have a virtual_relation_label to use this parameter)"
      },
      "target_qnode_id": {
        "is_required": false,
        "examples": [
          "n00",
          "n01"
        ],
        "type": "string",
        "description": "A specific target query node id (optional, otherwise applied to all edges, must have a virtual_relation_label to use this parameter)"
      }
    },
    "description": "\ncompute_ngd computes a metric (called the normalized Google distance) based on edge soure/target node co-occurrence in abstracts of all PubMed articles.\nThis information is then included as an edge attribute with the name normalized_google_distance.\nYou have the choice of applying this to all edges in the knowledge graph, or only between specified source/target qnode id's. If the later, virtual edges are added with the type specified by virtual_relation_label.\n                    "
  },
  "overlay(action=predict_drug_treats_disease)": {
    "parameters": {
      "virtual_relation_label": {
        "is_required": false,
        "examples": [
          "N1",
          "J2"
        ],
        "type": "string",
        "description": "An optional label to help identify the virtual edge in the relation field."
      },
      "source_qnode_id": {
        "is_required": false,
        "examples": [
          "n00",
          "n01"
        ],
        "type": "string",
        "description": "A specific source query node id (optional, otherwise applied to all edges, must have a virtual_relation_label to use this parameter)"
      },
      "target_qnode_id": {
        "is_required": false,
        "examples": [
          "n00",
          "n01"
        ],
        "type": "string",
        "description": "A specific target query node id (optional, otherwise applied to all edges, must have a virtual_relation_label to use this parameter)"
      }
    },
    "description": "\npredict_drug_treats_disease utilizes a machine learning model (trained on KP ARAX/KG1) to assign a probability that a given drug/chemical_substance treats a disease/phenotypic feature.\nFor more information about how this model was trained and how it performs, please see this publication (https://doi.org/10.1101/765305).\nThe drug-disease treatment prediction probability is included as an edge attribute (with the attribute name 'probability_treats').\nYou have the choice of applying this to all appropriate edges in the knowledge graph, or only between specified source/target qnode id's (make sure one is a chemical_substance, and the other is a disease or phenotypic_feature). \n                    "
  },
  "overlay(action=compute_jaccard)": {
    "parameters": {
      "start_node_id": {
        "is_required": true,
        "examples": [
          "DOID:1872",
          "CHEBI:7476",
          "UMLS:C1764836"
        ],
        "type": "string",
        "description": "A curie id specifying the starting node"
      },
      "intermediate_node_id": {
        "is_required": true,
        "examples": [
          "DOID:1872",
          "CHEBI:7476",
          "UMLS:C1764836"
        ],
        "type": "string",
        "description": "A curie id specifying the intermediate node"
      },
      "end_node_id": {
        "is_required": true,
        "examples": [
          "DOID:1872",
          "CHEBI:7476",
          "UMLS:C1764836"
        ],
        "type": "string",
        "description": "A curie id specifying the ending node"
      },
      "virtual_relation_label": {
        "is_required": true,
        "examples": [
          "N1",
          "J2",
          "FET"
        ],
        "type": "string",
        "description": "An optional label to help identify the virtual edge in the relation field."
      }
    },
    "description": "\ncompute_jaccard creates virtual edges and adds an edge attribute (with the property name 'jaccard_index') containing the following information:\nThe jaccard similarity measures how many 'intermediate_node_id's are shared in common between each 'start_node_id' and 'target_node_id'.\nThis is used for purposes such as \"find me all drugs ('start_node_id') that have many proteins ('intermediate_node_id') in common with this disease ('end_node_id').\"\nThis can be used for downstream filtering to concentrate on relevant bioentities.\n                    "
  },
  "overlay(action=fisher_exact_test)": {
    "parameters": {
      "source_qnode_id": {
        "is_required": true,
        "examples": [
          "n00",
          "n01"
        ],
        "type": "string",
        "description": "A specific source query node id (required)"
      },
      "virtual_relation_label": {
        "is_required": true,
        "examples": [
          "N1",
          "J2",
          "FET"
        ],
        "type": "string",
        "description": "An optional label to help identify the virtual edge in the relation field."
      },
      "target_qnode_id": {
        "is_required": true,
        "examples": [
          "n00",
          "n01"
        ],
        "type": "string",
        "description": "A specific target query node id (required)"
      },
      "rel_edge_id": {
        "is_required": false,
        "examples": [
          "e00",
          "e01"
        ],
        "type": "string",
        "description": "A specific QEdge id of edges connected to both source nodes and target nodes in message KG (optional, otherwise all edges connected to both source nodes and target nodes in message KG are considered), eg. 'e01'"
      },
      "top_n": {
        "is_required": false,
        "examples": [
          "all",
          5,
          50
        ],
        "type": "int or None",
        "description": "An int indicating the top number (the smallest) of p-values to return (optional, otherwise all results returned)",
        "default": null
      },
      "cutoff": {
        "is_required": false,
        "examples": [
          "all",
          0.05,
          0.95
        ],
        "type": "float or None",
        "description": "A float indicating the p-value cutoff to return the results (optional, otherwise all results returned), eg. 0.05",
        "default": null
      }
    },
    "description": "\nfisher_exact_test computes the Fisher's Exact Test p-values of the connection between a list of given nodes with specified query id (source_qnode_id eg. 'n01') to their adjacent nodes with specified query id (e.g. target_qnode_id 'n02') in the message knowledge graph. \nThis information is then added as an edge attribute to a virtual edge which is then added to the query graph and knowledge graph.\nIt can also allow you to filter out the user-defined insignificance of connections based on a specified p-value cutoff or return the top n smallest p-value of connections and only add their corresponding virtual edges to the knowledge graph.\n                    "
  },
  "overlay(action=add_node_pmids)": {
    "parameters": {
      "max_num": {
        "is_required": false,
        "examples": [
          "all",
          5,
          50
        ],
        "type": "int or string",
        "description": "The maximum number of values to return. Enter 'all' to return everything",
        "default": 100
      }
    },
    "description": "\nadd_node_pmids adds PubMed PMID's as node attributes to each node in the knowledge graph.\nThis information is obtained from mapping node identifiers to MeSH terms and obtaining which PubMed articles have this MeSH term\neither labeling in the metadata or has the MeSH term occurring in the abstract of the article.\n                    "
  },
  "overlay(action=overlay_clinical_info)": {
    "parameters": {
      "paired_concept_frequency": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "type": "string",
        "description": "Indicates if you want to use the paired concept frequency option. Mutually exlisive with: `paired_concept_frequency`, `observed_expected_ratio`, and `chi_square` if any of the oters are set to true while this is there will be an error."
      },
      "observed_expected_ratio": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "type": "string",
        "description": "Indicates if you want to use the paired concept frequency option. Mutually exlisive with: `paired_concept_frequency`, `observed_expected_ratio`, and `chi_square` if any of the oters are set to true while this is there will be an error."
      },
      "chi_square": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "type": "string",
        "description": "Indicates if you want to use the paired concept frequency option. Mutually exlisive with: `paired_concept_frequency`, `observed_expected_ratio`, and `chi_square` if any of the oters are set to true while this is there will be an error."
      },
      "virtual_relation_label": {
        "is_required": false,
        "examples": [
          "N1",
          "J2"
        ],
        "type": "string",
        "description": "An optional label to help identify the virtual edge in the relation field."
      },
      "source_qnode_id": {
        "is_required": false,
        "examples": [
          "n00",
          "n01"
        ],
        "type": "string",
        "description": "A specific source query node id (optional, otherwise applied to all edges, must have a virtual_relation_label to use this parameter)"
      },
      "target_qnode_id": {
        "is_required": false,
        "examples": [
          "n00",
          "n01"
        ],
        "type": "string",
        "description": "A specific target query node id (optional, otherwise applied to all edges, must have a virtual_relation_label to use this parameter)"
      }
    },
    "description": "\noverlay_clinical_info overlay edges with information obtained from the knowledge provider (KP) Columbia Open Health Data (COHD).\nThis KP has a number of different functionalities, such as 'paired_concept_frequency', 'observed_expected_ratio', etc. which are mutually exclusive DSL parameters.\nAll information is derived from a 5 year hierarchical dataset: Counts for each concept include patients from descendant concepts. \nThis includes clinical data from 2013-2017 and includes 1,731,858 different patients.\nThis information is then included as an edge attribute.\n                    "
  },
  "filter_kg(action=remove_edges_by_type)": {
    "parameters": {
      "edge_type": {
        "is_required": true,
        "examples": [
          "contraindicated_for",
          "affects",
          "expressed_in"
        ],
        "type": "string",
        "description": "The name of the edge type to filter by."
      },
      "remove_connected_nodes": {
        "is_required": false,
        "enum": [
          "true",
          "false",
          "True",
          "False",
          "t",
          "f",
          "T",
          "F"
        ],
        "type": "boolean",
        "description": "Indicates whether or not to remove the nodes connected to the edge.",
        "default": "false"
      },
      "qnode_id": {
        "is_required": false,
        "examples": [
          "n01",
          "n02"
        ],
        "type": "string",
        "description": "If remove_connected_nodes is set to True this indicates if you only want nodes corresponding to a specific qnode_id to be removed.If not provided the qnode_id will not be considered when filtering."
      }
    },
    "description": "\nremove_edges_by_type removes edges from the knowledge graph (KG) based on a given edge type.\n                    "
  },
  "filter_kg(action=remove_edges_by_attribute)": {
    "parameters": {
      "edge_attribute": {
        "is_required": true,
        "examples": [
          "jaccard_index",
          "observed_expected_ratio",
          "normalized_google_distance"
        ],
        "type": "string",
        "description": "The name of the edge attribute to filter on."
      },
      "direction": {
        "is_required": true,
        "enum": [
          "above",
          "below"
        ],
        "type": "string",
        "description": "Indictes whether to remove above or below the given threshold."
      },
      "threshold": {
        "is_required": true,
        "examples": [
          5,
          0.45
        ],
        "min": "-inf",
        "max": "inf",
        "type": "float",
        "description": "The threshold to filter with."
      },
      "remove_connected_nodes": {
        "is_required": false,
        "enum": [
          "true",
          "false",
          "True",
          "False",
          "t",
          "f",
          "T",
          "F"
        ],
        "type": "boolean",
        "description": "Indicates whether or not to remove the nodes connected to the edge.",
        "default": "false"
      },
      "qnode_id": {
        "is_required": false,
        "examples": [
          "n01",
          "n02"
        ],
        "type": "string",
        "description": "If remove_connected_nodes is set to True this indicates if you only want nodes corresponding to a specific qnode_id to be removed.If not provided the qnode_id will not be considered when filtering."
      }
    },
    "description": "\nremove_edges_by_attribute removes edges from the knowledge graph (KG) based on a a certain edge attribute.\nEdge attributes are a list of additional attributes for an edge.\nThis action interacts particularly well with overlay() as overlay() frequently adds additional edge attributes.\n                    "
  },
  "filter_kg(action=remove_edges_by_property)": {
    "parameters": {
      "edge_property": {
        "is_required": true,
        "examples": [
          "source_id",
          "provided_by",
          "is_defined_by"
        ],
        "type": "string",
        "description": "The name of the edge property to filter on."
      },
      "property_value": {
        "is_required": true,
        "examples": [
          "DOID:8398",
          "Pharos",
          "ARAX/RTX"
        ],
        "type": "string",
        "description": "The edge property value to indicate which edges to remove."
      },
      "remove_connected_nodes": {
        "is_required": false,
        "enum": [
          "true",
          "false",
          "True",
          "False",
          "t",
          "f",
          "T",
          "F"
        ],
        "type": "boolean",
        "description": "Indicates whether or not to remove the nodes connected to the edge.",
        "default": "false"
      },
      "qnode_id": {
        "is_required": false,
        "examples": [
          "n01",
          "n02"
        ],
        "type": "string",
        "description": "If remove_connected_nodes is set to True this indicates if you only want nodes corresponding to a specific qnode_id to be removed.If not provided the qnode_id will not be considered when filtering."
      }
    },
    "description": "\nremove_edges_by_property removes edges from the knowledge graph (KG) based on a given edge property.\n                    "
  },
  "filter_kg(action=remove_edges_by_stats)": {
    "parameters": {
      "edge_attribute": {
        "is_required": true,
        "examples": [
          "jaccard_index",
          "observed_expected_ratio",
          "normalized_google_distance"
        ],
        "type": "string",
        "description": "The name of the edge attribute to filter on."
      },
      "type": {
        "is_required": false,
        "enum": [
          "n",
          "std",
          "std_dev",
          "percentile",
          "p"
        ],
        "type": "string",
        "description": "The statistic to use for filtering.",
        "default": "n"
      },
      "direction": {
        "is_required": false,
        "enum": [
          "above",
          "below"
        ],
        "type": "string",
        "description": "Indictes whether to remove above or below the given threshold.",
        "default": "a value dictated by the `edge_attribute` parameter. If `edge attribute` is 'ngd', 'chi_square', 'fisher_exact', or 'normalized_google_distance' then `direction` defaults to above. If `edge_attribute` is 'jaccard_index', 'observed_expected_ratio', 'probability_treats' or anything else not listed then `direction` defaults to below."
      },
      "threshold": {
        "is_required": false,
        "examples": [
          5,
          0.45
        ],
        "min": 0,
        "max": "inf (or 100 if type=percentile or p)",
        "type": "float",
        "description": "The threshold to filter with.",
        "default": "a value dictated by the `type` parameter. If `type` is 'n' then `threshold` will default to 50. If `type` is 'std_dev' or 'std' then `threshold` will default to 1.If `type` is 'percentile' or 'p' then `threshold` will default to 95 unless `edge_attribute` is also 'ngd', 'chi_square', 'fisher_exact', or 'normalized_google_distance' then `threshold` will default to 5."
      },
      "top": {
        "is_required": false,
        "enum": [
          "true",
          "false",
          "True",
          "False",
          "t",
          "f",
          "T",
          "F"
        ],
        "type": "string",
        "description": "Indicate whether or not the threshold should be placed in top of the list. E.g. top set as True with type set as std_dev will set the cutoff for filtering as the mean + threshold * std_dev while setting top to False will set the cutoff as the mean - std_dev * threshold.",
        "default": "a value dictated by the `edge_attribute` parameter. If `edge attribute` is 'ngd', 'chi_square', 'fisher_exact', or 'normalized_google_distance' then `top` defaults to False. If `edge_attribute` is 'jaccard_index', 'observed_expected_ratio', 'probability_treats' or anything else not listed then `top` defaults to True."
      },
      "remove_connected_nodes": {
        "is_required": false,
        "enum": [
          "true",
          "false",
          "True",
          "False",
          "t",
          "f",
          "T",
          "F"
        ],
        "type": "boolean",
        "description": "Indicates whether or not to remove the nodes connected to the edge.",
        "default": "false"
      },
      "qnode_id": {
        "is_required": false,
        "examples": [
          "n01",
          "n02"
        ],
        "type": "string",
        "description": "If remove_connected_nodes is set to True this indicates if you only want nodes corresponding to a specific qnode_id to be removed.If not provided the qnode_id will not be considered when filtering."
      }
    },
    "description": "\nremove_edges_by_stats removes edges from the knowledge graph (KG) based on a certain edge attribute using default heuristics.\nEdge attributes are a list of additional attributes for an edge.\nThis action interacts particularly well with overlay() as overlay() frequently adds additional edge attributes.\n                    "
  },
  "filter_kg(action=remove_nodes_by_type)": {
    "parameters": {
      "node_type": {
        "is_required": true,
        "examples": [
          "chemical_substance",
          "disease"
        ],
        "type": "string",
        "description": "The name of the node type to filter by."
      }
    },
    "description": "\nremove_node_by_type removes nodes from the knowledge graph (KG) based on a given node type.\n                    "
  },
  "filter_kg(action=remove_nodes_by_property)": {
    "parameters": {
      "node_property": {
        "is_required": true,
        "examples": [
          "provided_by",
          "is_defined_by"
        ],
        "type": "string",
        "description": "The name of the node property to filter on."
      },
      "property_value": {
        "is_required": true,
        "examples": [
          "Pharos",
          "ARAX/RTX"
        ],
        "type": "string",
        "description": "The node property vaue to indicate which nodes to remove."
      }
    },
    "description": "\nremove_nodes_by_property removes nodes from the knowledge graph (KG) based on a given node property.\n                    "
  },
  "filter_kg(action=remove_orphaned_nodes)": {
    "parameters": {
      "node_type": {
        "is_required": false,
        "examples": [
          "chemical_substance",
          "disease"
        ],
        "type": "string",
        "description": "The name of the node type to filter by. If no value provided node type will not be considered."
      }
    },
    "description": "\nremove_orphaned_nodes removes nodes from the knowledge graph (KG) that are not connected via any edges.\nSpecifying a 'node_type' will restrict this to only remove orphaned nodes of a certain type.\nThis can be applied to an arbitrary knowledge graph as possible node types are computed dynamically (i.e. not just those created/recognized by the ARA Expander team).\n                    "
  },
  "filter_results(action=sort_by_edge_attribute)": {
    "parameters": {
      "edge_attribute": {
        "is_required": true,
        "examples": [
          "jaccard_index",
          "observed_expected_ratio",
          "normalized_google_distance"
        ],
        "type": "string",
        "description": "The name of the attribute to filter by."
      },
      "edge_relation": {
        "is_required": false,
        "examples": [
          "N1",
          "C1"
        ],
        "type": "string",
        "description": "The name of unique identifier to only filter on edges with matching relation field. (stored in the relation neo4j edge property) If not provided the edge relation will not be considered when filtering."
      },
      "direction": {
        "is_required": true,
        "examples": [
          "descending",
          "d",
          "ascending",
          "a"
        ],
        "type": "string",
        "description": "The direction in which to order results. (ascending or descending)"
      },
      "max_results": {
        "is_required": false,
        "examples": [
          5,
          10,
          50
        ],
        "min": 0,
        "max": "inf",
        "type": "int",
        "description": "The maximum number of results to return. If not provided all results will be returned."
      },
      "prune_kg": {
        "is_required": false,
        "enum": [
          "true",
          "false",
          "True",
          "False",
          "t",
          "f",
          "T",
          "F"
        ],
        "type": "boolean",
        "description": "This indicates if the Knowledge Graph (KG) should be pruned so that any nodes or edges not appearing in the results are removed from the KG.",
        "default": "true"
      }
    },
    "description": "\nsort_by_edge_attribute sorts the results by the edges based on a a certain edge attribute.\nEdge attributes are a list of additional attributes for an edge.\n                    "
  },
  "filter_results(action=sort_by_node_attribute)": {
    "parameters": {
      "node_attribute": {
        "is_required": true,
        "examples": [
          "pubmed_ids"
        ],
        "type": "string",
        "description": "The name of the attribute to filter by."
      },
      "node_type": {
        "is_required": false,
        "examples": [
          "chemical_substance",
          "disease"
        ],
        "type": "string",
        "description": "The name of the node type to only filter on nodes of the matching type. If not provided the node type will not be considered when filtering."
      },
      "direction": {
        "is_required": true,
        "examples": [
          "descending",
          "d",
          "ascending",
          "a"
        ],
        "type": "string",
        "description": "The direction in which to order results. (ascending or descending)"
      },
      "max_results": {
        "is_required": false,
        "examples": [
          5,
          10,
          50
        ],
        "min": 0,
        "max": "inf",
        "type": "int",
        "description": "The maximum number of results to return. If not provided all results will be returned."
      },
      "prune_kg": {
        "is_required": false,
        "enum": [
          "true",
          "false",
          "True",
          "False",
          "t",
          "f",
          "T",
          "F"
        ],
        "type": "boolean",
        "description": "This indicates if the Knowledge Graph (KG) should be pruned so that any nodes or edges not appearing in the results are removed from the KG.",
        "default": "true"
      }
    },
    "description": "\nsort_by_node_attribute sorts the results by the nodes based on a a certain node attribute.\nNode attributes are a list of additional attributes for an node.\n                    "
  },
  "filter_results(action=limit_number_of_results)": {
    "parameters": {
      "max_results": {
        "is_required": true,
        "examples": [
          5,
          10,
          50
        ],
        "min": 0,
        "max": "inf",
        "type": "int",
        "description": "The maximum number of results to return. If not provided all results will be returned."
      },
      "prune_kg": {
        "is_required": false,
        "enum": [
          "true",
          "false",
          "True",
          "False",
          "t",
          "f",
          "T",
          "F"
        ],
        "type": "boolean",
        "description": "This indicates if the Knowledge Graph (KG) should be pruned so that any nodes or edges not appearing in the results are removed from the KG.",
        "default": "true"
      }
    },
    "description": "\nlimit_number_of_results removes excess results over the specified maximum.\n                    "
  },
  "filter_results(action=sort_by_edge_count)": {
    "parameters": {
      "direction": {
        "is_required": true,
        "examples": [
          "descending",
          "d",
          "ascending",
          "a"
        ],
        "type": "string",
        "description": "The direction in which to order results. (ascending or descending)"
      },
      "max_results": {
        "is_required": false,
        "examples": [
          5,
          10,
          50
        ],
        "min": 0,
        "max": "inf",
        "type": "int",
        "description": "The maximum number of results to return. If not provided all results will be returned."
      },
      "prune_kg": {
        "is_required": false,
        "enum": [
          "true",
          "false",
          "True",
          "False",
          "t",
          "f",
          "T",
          "F"
        ],
        "type": "boolean",
        "description": "This indicates if the Knowledge Graph (KG) should be pruned so that any nodes or edges not appearing in the results are removed from the KG.",
        "default": "true"
      }
    },
    "description": "\nsort_by_edge_count sorts the results by the number of edges in the results.\n                    "
  },
  "filter_results(action=sort_by_node_count)": {
    "parameters": {
      "direction": {
        "is_required": true,
        "examples": [
          "descending",
          "d",
          "ascending",
          "a"
        ],
        "type": "string",
        "description": "The direction in which to order results. (ascending or descending)"
      },
      "max_results": {
        "is_required": false,
        "examples": [
          5,
          10,
          50
        ],
        "min": 0,
        "max": "inf",
        "type": "int",
        "description": "The maximum number of results to return. If not provided all results will be returned."
      },
      "prune_kg": {
        "is_required": false,
        "enum": [
          "true",
          "false",
          "True",
          "False",
          "t",
          "f",
          "T",
          "F"
        ],
        "type": "boolean",
        "description": "This indicates if the Knowledge Graph (KG) should be pruned so that any nodes or edges not appearing in the results are removed from the KG.",
        "default": "true"
      }
    },
    "description": "\nsort_by_node_count sorts the results by the number of nodes in the results.\n                    "
  },
  "resultify()": {
    "parameters": {
      "ignore_edge_direction": {
        "is_required": false,
        "examples": [
          "true",
          "false"
        ],
        "enum": [
          "true",
          "false"
        ],
        "default": "true",
        "type": "boolean",
        "description": "Whether to ignore (vs. obey) edge directions in the query graph when identifying paths that fulfill it."
      }
    },
    "description": "Creates a list of results consisting of subgraphs from the message knowledge graph that satisfy the query graph."
  },
  "rank_results()": {
    "parameters": {},
    "description": "\nrank_results iterates through all edges in the results list aggrigating and \nnormalizing the scores stored within the edge_attributes property. After combining these scores into \none score the ranker then scores each result through a combination of max flow, longest path, \nand frobenius norm.\n        "
  }
}
